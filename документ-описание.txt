Реализация кучи:
Куча представляет из себя абстрактный тип данных основанный на бинарном дереве, 
но реализованный на основе массива(в моем случае на основе вектора). Чтобы структура данных называлась кучей, она должна удовлетворять условию - 
потомки каждого узла должны иметь меньший приоритет, чем этот узел. В данном случае куча реализованна восходящей,
то есть наибольший элемент в корне.

Всплывание элемента работает следующим образом - мы добавляем элемент в самую левую свободную позицию на самом нижнем уровне дерева,
если новый узел имеет приоритет выше чем родительский то мы обмениваем их местами 
и этот шаг проделывается до тех пор пока приоритет родительского
не будет выше  приоритета текущего элемента или если текущий элемент не станет корнем.

Опускание элемента работает следующим образом - мы сравниваем узел с двумя его потомками и меняем местами с наибольшим из них. 
Этот шаг проделывается
до тех пор пока наибольшим элементом из двух потомков и узла не будет сам узел 
или же если он не дойдет до самого нижнего уровня и самой левой свободной позиции.


Очередь с приоритетом:
Очередь с приоритетом   это абстрактный тип данных основанный на другом абстрактном типе данных - куче.
Она хранит в себе элементы каждому из которых сопоставлен приоритет, элементы извлекаются из очереди в порядке убывания приоритета.

Алгоритм Прима:
Алгоритм заключается в поиске минимального остовного дерева графа. Искомый минимальный остов строится постепенно, 
добавлением в него рёбер по одному. Изначально остов полагается состоящим из единственной вершины (её можно выбрать произвольно). 
Затем выбирается ребро минимального веса, исходящее из этой вершины, и добавляется в минимальный остов. 
После этого остов содержит уже две вершины, и теперь ищется и добавляется ребро минимального веса, 
имеющее один конец в одной из двух выбранных вершин, а другой — наоборот, во всех остальных, кроме этих двух. 
И так далее, т.е. всякий раз ищется минимальное по весу ребро, один конец которого — уже взятая в остов вершина, 
а другой конец — ещё не взятая, и это ребро добавляется в остов (если таких рёбер несколько, можно взять любое). 
Этот процесс повторяется до тех пор, пока остов не станет содержать все вершины (или, что то же самое, n-1 ребро).
В итоге будет построен остов, являющийся минимальным. 
Если граф был изначально не связен, то остов найден не будет (количество выбранных рёбер останется меньше n-1).



